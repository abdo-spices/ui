{
  "name": "table",
  "type": "registry:ui",
  "dependencies": [],
  "registryDependencies": [
    "combobox",
    "input",
    "pagination",
    "scroll-area",
    "dropdown",
    "command",
    "button",
    "checkbox",
    "badge",
    "context-menu",
    "tooltip"
  ],
  "root_folder": "registry-ui-components/table",
  "files": [
    {
      "path": "registry-ui-components/table/index.ts",
      "content": "export * from './table'\nexport * from './table.hook'\nexport * from './table.lib'\nexport * from './table.constants'\nexport * from './table.types'\n",
      "type": "registry:ui"
    },
    {
      "path": "registry-ui-components/table/table-advanced.tsx",
      "content": "import React from 'react'\nimport { cn } from '@/lib'\nimport {\n  DuckTableContextType,\n  DuckTableProps,\n  DuckTableProviderProps,\n  TableColumnType,\n  TableSearchStateType,\n} from './table-advanced.types'\nimport { Table } from './table'\nimport { ScrollArea, ScrollBar } from '@/registry/default/ui/scroll-area'\nimport {\n  TableHead,\n  TableHeader,\n  TableRow,\n} from '@/registry/default/ui/ShadcnUI/table'\nimport { Checkbox } from '@/registry/default/ui/checkbox'\nimport {\n  DropdownMenuOptionsDataType,\n  DropdownMenuView,\n} from '@/registry/default/ui/dropdown-menu'\nimport { ArrowDownIcon, ArrowUpIcon, LucideIcon } from 'lucide-react'\nimport { CaretSortIcon } from '@radix-ui/react-icons'\n\nexport const DuckTableContext =\n  React.createContext<DuckTableContextType<any> | null>(null)\n\nexport function useDuckTable() {\n  const context = React.useContext(DuckTableContext)\n  if (!context) {\n    throw new Error('useTableProvider must be used within an TableProvider')\n  }\n  return context\n}\n\nexport function DuckTableProvider<TColumnName extends string[]>({\n  table_rows,\n  table_columns,\n  children,\n  className,\n  ...props\n}: DuckTableProviderProps<TColumnName>) {\n  const [search, setSearch] = React.useState<TableSearchStateType>({\n    query: '',\n    queryBy: [],\n  })\n\n  return (\n    <DuckTableContext.Provider\n      value={{\n        table_columns,\n        table_rows,\n        search,\n        setSearch,\n      }}\n    >\n      <div\n        className={cn(\n          `w-full- flex flex-col gap-4 w-[800px] h-[500px]`,\n          className,\n        )}\n        {...props}\n      >\n        {children}\n      </div>\n    </DuckTableContext.Provider>\n  )\n}\nDuckTableProvider.displayName = 'DuckTableProvider'\n\nexport function DuckTable({\n  wrapper,\n  className,\n  children,\n  ...props\n}: DuckTableProps) {\n  const { className: wrapperClassName, ...wrapperProps } = wrapper! ?? {}\n\n  return (\n    <ScrollArea\n      className={cn(\n        'border border-border rounded-lg !overflow-visible relative',\n        wrapperClassName,\n      )}\n      {...wrapperProps}\n    >\n      <Table {...props}>{children}</Table>\n      <ScrollBar orientation=\"horizontal\" />\n    </ScrollArea>\n  )\n}\nDuckTable.displayName = 'DuckTable'\n\n// ------------------------------------------------------------------------------------------------\n\nexport interface DuckTableHeaderProps {}\n\nexport function DuckTableHeader({}: DuckTableHeaderProps) {\n  const { table_columns } = useDuckTable()\n  return (\n    <>\n      <TableHeader>\n        <TableRow>\n          {table_columns?.map((column, idx) => {\n            const {\n              children,\n              className,\n              sortable,\n              label,\n              showLabel,\n              dropdownMenuOptions,\n              currentSort,\n              ...props\n            } = column\n\n            // const actionsArgs = {\n            //   sortArray,\n            //   setTableData,\n            //   setHeaders,\n            //   column,\n            //   idx,\n            //   data: tableData,\n            //   headers,\n            //   tableData,\n            // } as unknown as TableDropdownMenuOptionsType<C>\n\n            return (\n              <React.Fragment key={idx}>\n                {idx === 0 && (\n                  <DuckTableCheckbox\n                    type=\"header\"\n                    className={cn(dropdownMenuOptions?.length && 'justify-end')}\n                  />\n                )}\n                <TableHead\n                  className={cn('py-2', sortable && 'px-2', className)}\n                  {...props}\n                >\n                  {/*NOTE: Rendering Sorting else rendering label*/}\n                  {!sortable ? (\n                    <span className=\"capitalize\">\n                      {(label as string) ?? children}\n                    </span>\n                  ) : (\n                    <DuckTableHeadSelectable\n                      column={column}\n                      label={(label as string) ?? children}\n                      showLabel={showLabel}\n                      dropdownMenuOptions={dropdownMenuOptions}\n                    />\n                  )}\n                </TableHead>\n              </React.Fragment>\n            )\n          })}\n        </TableRow>\n      </TableHeader>\n    </>\n  )\n}\nDuckTableHeader.displayName = 'TableCustomViewHeader'\n\nexport interface DuckTableCheckboxProps\n  extends React.ComponentPropsWithoutRef<typeof TableHead> {\n  selectable?: boolean | undefined\n  type: 'header' | 'body'\n}\n\nexport function DuckTableCheckbox({\n  className,\n  selectable,\n  type,\n  ...props\n}: DuckTableCheckboxProps) {\n  const Component =\n    //TODO: type to fix this type hence i want it to be compatible with both Row and Head.\n    (type === 'header' ? TableHead : TableRow) as typeof TableHead\n\n  return (\n    <Component\n      className={cn(\n        'flex items-center w-full data-[state=open]:bg-accent text-xs capitalize h-[51px] py-2',\n        className,\n      )}\n      {...props}\n    >\n      {selectable && (\n        <Checkbox\n          className=\"border-border\"\n          // onClick={() => {\n          //   setSelected(selected.length === tableData.length ? [] : tableData.map(item => item)\n          // }}\n          // checked={\n          // selected.length === tableData.length\n          //   ? true\n          //   : selected.length < tableData.length && selected.length\n          //     ? 'indeterminate'\n          //     : false\n          // }\n        />\n      )}\n    </Component>\n  )\n}\n\nexport interface DuckTableHeadSelectableProps<TSort extends boolean = true>\n  extends React.HTMLProps<HTMLDivElement> {\n  column: TableColumnType<TSort>\n  label: string\n  showLabel?: boolean | undefined\n  dropdownMenuOptions: any\n}\n\nexport function DuckTableHeadSelectable<TSort extends boolean = true>({\n  column,\n  label,\n  showLabel,\n  dropdownMenuOptions,\n  children,\n}: DuckTableHeadSelectableProps<TSort>) {\n  //NOTE: passing the actionsArgs to the onClick function\n  const fullDropDownMenuOptions = React.useMemo(\n    () =>\n      dropdownMenuOptions?.map((item) => {\n        return {\n          ...item,\n          onClick: (\n            e:\n              | React.MouseEvent<HTMLButtonElement>\n              | React.MouseEvent<HTMLDivElement>,\n          ) => {\n            // item.action?.(e, actionsArgs)\n          },\n        }\n      }),\n    [],\n  )\n\n  return (\n    <div className={cn('flex items-center space-x-2')}>\n      {(dropdownMenuOptions?.length ?? 0) > 0 && (\n        <DropdownMenuView\n          trigger={{\n            size: 'sm',\n            variant: 'ghost',\n            className:\n              'data-[state=open]:bg-accent [&>div]:justify-between w-full [&>div]:w-full capitalize',\n            secondIcon: {\n              className: '-ml-3',\n              children: (column?.currentSort === 'asc'\n                ? ArrowDownIcon\n                : column?.currentSort === 'desc'\n                  ? ArrowUpIcon\n                  : CaretSortIcon) as LucideIcon,\n            },\n            children: (label as string) ?? children,\n            label: showLabel\n              ? {\n                  children: label.toString() + ' options',\n                  className: 'capitalize',\n                  showLabel: true,\n                  side: 'top',\n                }\n              : undefined,\n          }}\n          content={{\n            align: 'center',\n            options: {\n              group: [2, 1],\n              optionsData: fullDropDownMenuOptions as\n                //+FIX: the type\n                DropdownMenuOptionsDataType<true> | undefined,\n            },\n          }}\n        />\n      )}\n    </div>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry-ui-components/table/table-advanced.types.ts",
      "content": "import React from 'react'\nimport { ScrollArea } from '@/registry/default/ui/scroll-area'\nimport { IconProps } from '@radix-ui/react-icons/dist/types'\nimport { Table } from '@/registry/default/ui/ShadcnUI/table'\nimport { LabelType } from '../button'\nimport { DropdownMenuOptionsDataType } from '@/registry/default/ui/dropdown-menu'\nimport { TableDropdownMenuOptionsType } from './table.types'\nimport { sortArray } from './table.lib'\n\n// ------------------------------------------------------------------------------------------------\n// NOTE:  These types are used for the `table-advanced` context.\n// ------------------------------------------------------------------------------------------------\n\nexport interface DuckTableProviderProps<TColumnName extends string[]>\n  extends React.HTMLAttributes<HTMLDivElement> {\n  table_columns: readonly TableColumnType[]\n  table_rows: TableContentDataType<TColumnName>[]\n}\n\nexport type DuckTableContextType<TColumnName extends string[]> = {\n  table_columns: readonly TableColumnType[]\n  table_rows: TableContentDataType<TColumnName>[]\n  search: TableSearchStateType\n  setSearch: React.Dispatch<React.SetStateAction<TableSearchStateType>>\n  sortBy: TableSortByStateType<TColumnName>\n  setSortBy: React.Dispatch<\n    React.SetStateAction<TableSortByStateType<TColumnName>>\n  >\n}\n\nexport type TableSortByStateType<TColumnName extends string[]> = {\n  label: TColumnName[number]\n  type: 'asc' | 'desc'\n}\n\nexport interface TableSearchStateType {\n  query: string\n  queryBy: string[]\n}\n\n// ------------------------------------------------------------------------------------------------\n// NOTE:  These types are used for the `table-advanced` Components.\n// ------------------------------------------------------------------------------------------------\n\nexport interface DuckTableProps\n  extends React.ComponentPropsWithoutRef<typeof Table> {\n  wrapper?: React.ComponentPropsWithoutRef<typeof ScrollArea>\n}\n\n// ------------------------------------------------------------------------------------------------\n// NOTE:  These types are used for the `table-advanced, hence i use them to get the types.\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Extracts the `label` property from an array of `TableColumnType` objects\n * and returns a tuple of string literals representing the column labels.\n *\n * ### Type Safety Guidelines:\n * 1. Ensure the `columns` array is defined as `const` to preserve type inference.\n * 2. Use `readonly TableColumnType[]` to enforce immutability and proper inference.\n *\n * #### Inferring Labels as a Union\n * - Append `[number]` to the type to extract a union of possible labels.\n * ```ts\n * type ColumnLabel = GetColumnLabel<typeof columns>[number]; // 'Name' | 'Age' | 'Email'\n * ```\n *\n * #### Defining Columns and Extracting Labels\n * ```ts\n * // Define columns as a strongly typed readonly array\n * const columns = [\n *   { label: \"Name\" },\n *   { label: \"Age\" },\n *   { label: \"Email\" }\n * ] as const satisfies readonly TableColumnType[];\n *\n * // Extract column labels as a tuple of string literals\n * type ColumnLabels = GetColumnLabel<typeof columns>; // ['Name', 'Age', 'Email']\n * ```\n */\nexport type GetColumnLabel<TColumn extends readonly TableColumnType[]> = {\n  -readonly [K in keyof TColumn]: `${TColumn[K]['label']}`\n}\n\n/**\n * Defines the column type for a table based on a dynamic set of column names.\n *\n * ### Type Safety Guidelines:\n * 1. Define the columns array as `const` to infer the most precise type.\n * 2. Ensure the type satisfies `readonly string[]` to preserve strict type checking.\n *\n * #### Inferring Column Names as a Union\n * - Append `[number]` to the type to infer a union of possible column names.\n * ```ts\n * type ColumnName = TColumnName[number]; // Infers as a union of column names\n * ```\n *\n * #### Defining Columns and Extracting Names\n * ```ts\n * // Define column names as a strongly typed readonly array\n * const columnNames = ['name', 'age', 'email'] as const;\n *\n * // Extract column names as a union type\n * type ColumnName = typeof columnNames[number]; // 'name' | 'age' | 'email'\n * ```\n *\n * #### Example Usage\n * ```ts\n * type MyTableColumns = TableContentDataType<typeof columnNames>;\n *\n * const columns: MyTableColumns = {\n *   name: { label: \"Full Name\", children: \"firstName\", icon: { name: \"user\" } },\n *   age: { label: \"Age\", icon: { name: \"calendar\" } },\n *   email: { label: \"Email Address\" }\n * };\n * ```\n */\nexport type TableContentDataType<TColumnName extends readonly string[]> = {\n  [key in TColumnName[number]]: TableColumnType & {\n    children?: TColumnName[number]\n    icon?: IconProps\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport interface TableColumnType<TSort extends boolean = true>\n  extends Partial<React.HTMLProps<HTMLTableCellElement>> {\n  label: string\n  sortable?: boolean\n  showLabel?: boolean\n  currentSort?: TSort extends true ? 'asc' | 'desc' | 'not sorted' : never\n  dropdownMenuOptions?: TSort extends true\n    ? DropdownMenuOptionsDataType<TableDropdownMenuOptionsType<TSort>>[]\n    : never\n}\n\nexport interface TableDropdownMenuOptionsType<T extends boolean> {\n  sortArray: typeof sortArray\n  setHeaders: React.Dispatch<React.SetStateAction<TableColumnType[]>>\n  headers: TableColumnType[]\n  tableData: TableContentDataType<T>[]\n  setTableData: React.Dispatch<React.SetStateAction<TableContentDataType<T>[]>>\n  data: TableContentDataType<T>[]\n  idx: number\n  column: TableColumnType\n}\n\nexport interface TableColumnType extends React.HTMLProps<HTMLTableCellElement> {\n  // TODO: bro what the fuck is this, the old code looks bloated af.\n  // FIX: make sure to sue these in the feture\n  withLabel?: Omit<LabelType, 'showCommand' | 'showLabel'>\n  withIcon?: React.ReactNode\n}\n// ------------------------------------------------------------------------------------------------\n//NOTE: not used yet.\nexport type TableDataFilteredType<T extends Record<string, unknown>> = {\n  [K in keyof T]: [K, T[K]]\n}[keyof T][]\n\nexport interface TablePaginationStateType {\n  pageSize: number\n  pageIndex: number\n}\n\nexport interface TableSelectionStateType {\n  rowSelected: Record<string, unknown>[]\n}\n\nexport type ColumnsViewedStateType<T extends Record<string, unknown>> =\n  TableColumnType<T> | null\n\nexport type OrderStateType = {\n  orderBy: string\n  orderDir: 'asc' | 'desc'\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry-ui-components/table/table.constants.ts",
      "content": "export const PAGE_SIZE = 6\nexport const PAGE_INDEX = 0\n",
      "type": "registry:ui"
    },
    {
      "path": "registry-ui-components/table/table.hook.tsx",
      "content": "import React from 'react'\nimport { DuckTableContext, type DuckTableContextType } from './table'\n\nexport const useDuckTable = <\n  Column extends Record<string, unknown> = Record<string, unknown>,\n>(): DuckTableContextType<Column> | null => {\n  const context = React.useContext(DuckTableContext)\n  if (!context) {\n    throw new Error('useTableProvider must be used within an TableProvider')\n  }\n  return context\n}\n\n// <TableRow key={idx}>\n//                  {tableDataFiltered.map(([key, value], idx) => {\n//                    const headersEntries = headers.map(\n//                      item => item.label.toString().toLowerCase() ?? item.children?.toString().toLowerCase()\n//                    )\n//                    const { className, children, withLabel, ...props } = value\n//                    const {\n//                      className: labelClassName,\n//                      children: labelChildren,\n//                      type: labelType = 'default',\n//                      ...labelProps\n//                    } = item?.[key]?.withLabel ?? {}\n//\n//                    return (\n//                      headersEntries.includes(key.toString().toLowerCase()) && (\n//                        <TableCell\n//                          key={key}\n//                          className={cn('py-2 h-[50px]', selected.includes(item) && 'bg-muted', className)}\n//                          {...props}\n//                        >\n//                          <div\n//                            className={cn(\n//                              'items-center gap-2 flex w-full',\n//                              headers?.[idx]?.className,\n//                              className,\n//                              idx === headersEntries.length - 1 && dropdownMenu && 'justify-between w-full'\n//                            )}\n//                          >\n//                            {/*NOTE: Rendering Checkbox */}\n//                            {selection && idx === 0 && (\n//                              <Checkbox\n//                                className=\"border-border\"\n//                                onClick={() =>\n//                                  setSelected(\n//                                    selected.includes(item) ? selected.filter(i => i !== item) : [...selected, item]\n//                                  )\n//                                }\n//                                checked={selected.includes(item)}\n//                              />\n//                            )}\n//\n//                            {/*NOTE: Rendering Label */}\n//                            {labelChildren && (\n//                              <Badge\n//                                variant={'outline'}\n//                                size={'sm'}\n//                                className={cn(labelType === 'default' ? '' : 'bg-red-500', labelClassName)}\n//                                {...labelProps}\n//                              >\n//                                {labelChildren}\n//                              </Badge>\n//                            )}\n//\n//                            <div className=\"flex items-center gap-2 text-ellipsis overflow-hidden whitespace-nowrap\">\n//                              {/*NOTE: Getting Icons from Filter Data */}\n//                              {filtersData?.length &&\n//                                filtersData?.map(item => {\n//                                  return item?.content?.data.map((item, idx) => {\n//                                    const { children: Icon, ...props } = item?.element?.icon ?? {}\n//                                    return item.label?.toString().toLowerCase() ===\n//                                      (children as string).toString().toLowerCase() ? (\n//                                      <span\n//                                        className=\"whitespace-nowrap\"\n//                                        key={idx}\n//                                      >\n//                                        {(Icon ? <Icon {...props} /> : '') as React.ReactNode}\n//                                      </span>\n//                                    ) : null\n//                                  })\n//                                })}\n//\n//                              {/*NOTE: Rendering the row column childrend */}\n//                              <span className=\"text-ellipsis overflow-hidden whitespace-nowrap\">{children}</span>\n//                            </div>\n//                            {/*NOTE: Dropdown Menu */}\n//                            {idx === headersEntries.length - 1 && dropdownMenu.optionsData?.length && (\n//                              <DropdownMenuView\n//                                trigger={{\n//                                  className: 'flex h-8 w-8 p-0 data-[state=open]:bg-muted',\n//                                  children: <span className=\"sr-only\">Open menu</span>,\n//                                  variant: 'ghost',\n//                                  size: 'icon',\n//                                  icon: {\n//                                    children: Ellipsis,\n//                                    className: 'h-4 w-4',\n//                                  },\n//                                }}\n//                                content={{\n//                                  align: 'end',\n//                                  options: dropdownMenu,\n//                                }}\n//                              />\n//                            )}\n//                          </div>\n//                        </TableCell>\n//                      )\n//                    )\n//                  })}\n//                </TableRow>\n//\n",
      "type": "registry:ui"
    },
    {
      "path": "registry-ui-components/table/table.lib.ts",
      "content": "import { DropdownMenuOptionsDataType } from '@/registry/default/ui/dropdown-menu'\nimport { Order, TableContentDataType, TableHeaderType } from './table.types'\nimport { ColumnsViewedStateType } from './table'\n\nexport function sortArray<T>(columns: TableHeaderType[], array: T[], key?: keyof T, order: Order = 'desc') {\n  const toggleSortOrder = (currentOrder: Order): Order => {\n    if (currentOrder === 'not sorted') return order\n    if (currentOrder === 'asc' && order === 'asc') return 'not sorted'\n    if (currentOrder === 'asc' && order === 'desc') return 'desc'\n    if (currentOrder === 'desc' && order === 'desc') return 'not sorted'\n    if (currentOrder === 'desc' && order === 'asc') return 'asc'\n    return 'not sorted'\n  }\n\n  const updatedColumns = columns.map(col => {\n    if (col.label === key) {\n      return {\n        ...col,\n        currentSort: toggleSortOrder(col.currentSort ?? 'not sorted'),\n      }\n    }\n    return col\n  })\n\n  const sortedData = array.toSorted((a, b) => {\n    const valueA = key ? (a[key] as TableContentDataType).children : a\n    const valueB = key ? (b[key] as TableContentDataType).children : b\n\n    if (order === 'not sorted' || !key) return 0\n\n    if (typeof valueA === 'string' && typeof valueB === 'string') {\n      return order === 'asc' ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA)\n    } else if (typeof valueA === 'number' && typeof valueB === 'number') {\n      return order === 'asc' ? valueA - valueB : valueB - valueA\n    } else {\n      return order === 'asc' ? (valueA > valueB ? 1 : -1) : valueA < valueB ? 1 : -1\n    }\n  })\n\n  return { sortedData, updatedColumns }\n}\n\nexport type OptionsDataType<T extends Record<string, unknown>> = {\n  header: ColumnsViewedStateType<T>[]\n  columnsViewed?: ColumnsViewedStateType<T>[]\n  setColumnsViewed?: React.Dispatch<React.SetStateAction<ColumnsViewedStateType<T>[]>>\n}\n\nexport function get_options_data<T extends Record<string, unknown> = Record<string, string>>({\n  header,\n  columnsViewed,\n  setColumnsViewed,\n}: OptionsDataType<T>) {\n  return header.map((column, idx) => {\n    const { children, className, label, sortable, disabled, currentSort, dropdownMenuOptions, ...props } = column ?? {}\n\n    return {\n      key: idx,\n      className: 'capitalize',\n      checked: columnsViewed?.some(headerItem => headerItem?.label === label),\n      disabled: disabled,\n      onCheckedChange: () => {\n        setColumnsViewed?.(prevHeaders => {\n          const exists = prevHeaders.some(headerItem => headerItem?.label === label)\n\n          if (exists) {\n            return prevHeaders.filter(headerItem => headerItem?.label !== label)\n          }\n\n          const originalIndex = header.findIndex(headerItem => headerItem?.label === label)\n          const newHeaders = [...prevHeaders]\n          newHeaders.splice(originalIndex, 0, column)\n          return newHeaders.sort(\n            (a, b) =>\n              header.findIndex(headerItem => headerItem?.label === a?.label) -\n              header.findIndex(headerItem => headerItem?.label === b?.label)\n          )\n        })\n      },\n      children: label ?? children,\n      ...props,\n    }\n  }) as DropdownMenuOptionsDataType<T>[]\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry-ui-components/table/table.tsx",
      "content": "import * as React from 'react'\n\nimport { Checkbox } from '@/registry/default/ui/checkbox'\nimport { ScrollArea, ScrollBar } from '@/registry/default/ui/scroll-area'\nimport { PaginationCustomView } from '@/registry/default/ui/pagination'\nimport { Input } from '@/registry/default/ui/input'\nimport { Combobox, type ComboboxType } from '@/registry/default/ui/combobox'\nimport {\n  CommandShortcut,\n  type CommandListGroupDataType,\n} from '@/registry/default/ui/command'\nimport {\n  type DropdownMenuOptionsDataType,\n  DropdownMenuView,\n} from '@/registry/default/ui/dropdown-menu'\nimport {\n  ContextCustomView,\n  DuckContextMenuProps,\n} from '@/registry/default/ui/context-menu'\n\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from '../tooltip'\nimport { LabelType } from '../button'\nimport { Badge } from '../badge'\nimport { useDebounceCallback } from '@/hooks'\nimport { get_options_data } from './table.lib'\nimport { PAGE_INDEX, PAGE_SIZE } from './table.constants'\nimport { useDuckTable } from './table.hook'\nimport {\n  TableDropdownMenuOptionsType,\n  TableHeaderType,\n  TablePaginationType,\n} from './table.types'\n\nimport { cn, groupArrays } from '@/lib/utils'\n\nimport {\n  ArrowDownIcon,\n  ArrowUpIcon,\n  CirclePlus,\n  LucideIcon,\n} from 'lucide-react'\nimport { CaretSortIcon, MixerHorizontalIcon } from '@radix-ui/react-icons'\nimport { Separator } from '@/registry/default/ui'\n\n/*\n *  - This's the normal table components.\n *  It's a custom table component, you can use the dataTable Functionality down\n *  this file to make sure you get the best performance, out of this table with\n *  a more customized design.\n */\nconst Table = React.forwardRef<\n  HTMLTableElement,\n  React.HTMLAttributes<HTMLTableElement>\n>(({ className, ...props }, ref) => (\n  <div className=\"relative w-full overflow-auto\">\n    <table\n      ref={ref}\n      className={cn('w-full caption-bottom text-sm', className)}\n      {...props}\n    />\n  </div>\n))\nTable.displayName = 'Table'\n\nconst TableHeader = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <thead ref={ref} className={cn('[&_tr]:border-b', className)} {...props} />\n))\nTableHeader.displayName = 'TableHeader'\n\nconst TableBody = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tbody\n    ref={ref}\n    className={cn('[&_tr:last-child]:border-0', className)}\n    {...props}\n  />\n))\nTableBody.displayName = 'TableBody'\n\nconst TableFooter = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tfoot\n    ref={ref}\n    className={cn(\n      'border-t bg-muted/50 font-medium [&>tr]:last:border-b-0',\n      className,\n    )}\n    {...props}\n  />\n))\nTableFooter.displayName = 'TableFooter'\n\nconst TableRow = React.forwardRef<\n  HTMLTableRowElement,\n  React.HTMLAttributes<HTMLTableRowElement>\n>(({ className, ...props }, ref) => (\n  <tr\n    ref={ref}\n    className={cn(\n      'border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted',\n      className,\n    )}\n    {...props}\n  />\n))\nTableRow.displayName = 'TableRow'\n\nconst TableHead = React.forwardRef<\n  HTMLTableCellElement,\n  React.ThHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <th\n    ref={ref}\n    className={cn(\n      'h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0',\n      className,\n    )}\n    {...props}\n  />\n))\nTableHead.displayName = 'TableHead'\n\nconst TableCell = React.forwardRef<\n  HTMLTableCellElement,\n  React.TdHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <td\n    ref={ref}\n    className={cn('p-4 align-middle [&:has([role=checkbox])]:pr-0', className)}\n    {...props}\n  />\n))\nTableCell.displayName = 'TableCell'\n\nconst TableCaption = React.forwardRef<\n  HTMLTableCaptionElement,\n  React.HTMLAttributes<HTMLTableCaptionElement>\n>(({ className, ...props }, ref) => (\n  <caption\n    ref={ref}\n    className={cn('mt-4 text-sm text-muted-foreground', className)}\n    {...props}\n  />\n))\nTableCaption.displayName = 'TableCaption'\n\nexport const DuckTableBar = ({\n  children,\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => {\n  return (\n    <div\n      className={cn(\n        'flex items-end lg:items-center justify-between gap-2',\n        className,\n      )}\n      {...props}\n    >\n      {children}\n    </div>\n  )\n}\n\nexport interface DuckTableSearchProps extends React.HTMLProps<HTMLDivElement> {\n  input?: DuckTableSearchInputProps\n}\n\nexport const DuckTableSearch = ({\n  children,\n  className,\n  input,\n  ...props\n}: DuckTableSearchProps) => {\n  const { setSearch } = useDuckTable() ?? {}\n\n  //NOTE: Debounce search\n  const debouncedSearch = useDebounceCallback(\n    (newValue: string) => setSearch?.((_) => ({ query: newValue })),\n    500,\n  )\n\n  return (\n    <div\n      className={cn('flex flex-1 items-center space-x-2', className)}\n      {...props}\n    >\n      <DuckTableSearchInput\n        {...input}\n        trigger={{\n          ...input?.trigger,\n          onChange: (event: React.ChangeEvent<HTMLInputElement>) =>\n            debouncedSearch(event.target.value),\n        }}\n      />\n    </div>\n  )\n}\n\nexport interface DuckTableSearchInputProps {\n  trigger: React.ComponentPropsWithoutRef<typeof Input>\n  label?: LabelType\n  badge?: React.ComponentPropsWithoutRef<typeof CommandShortcut>\n  keys?: string[]\n}\n\nconst DuckTableSearchInput = React.forwardRef<\n  React.ElementRef<typeof Input>,\n  DuckTableSearchInputProps\n>(({ trigger, label, badge, keys }, ref) => {\n  const {\n    children: badgeChildren = '⌃+⇧+F',\n    className: badgeClassName,\n    ...badgeProps\n  } = badge ?? {}\n  const {\n    children: labelChildren = 'Filter tasks...',\n    className: labelClassName,\n    ...labelProps\n  } = label ?? {}\n  const {\n    className: triggerClassName = 'h-8 w-[150px] lg:w-[200px]',\n    placeholder = 'Filter tasks...',\n    ...triggerProps\n  } = trigger ?? {}\n\n  //NOTE: Duck shortcut\n  const inputRef = React.useRef<HTMLInputElement>(null)\n  // useDuckShortcut(\n  //   {\n  //     keys: keys ?? ['ctrl+shift+f'],\n  //     onKeysPressed: () => {\n  //       if (inputRef.current) {\n  //         inputRef.current.focus()\n  //       }\n  //     },\n  //   },\n  //   [inputRef],\n  // )\n  //\n\n  return (\n    <div className=\"flex flex-col\" ref={ref}>\n      <Tooltip delayDuration={100}>\n        <TooltipTrigger>\n          <Input\n            className={cn('h-8 w-[150px] lg:w-[200px]', triggerClassName)}\n            ref={inputRef}\n            placeholder={placeholder}\n            {...triggerProps}\n          />\n        </TooltipTrigger>\n        <TooltipContent\n          className={cn(\n            'flex items-center gap-2 z-50 justify-start',\n            labelClassName,\n          )}\n          {...labelProps}\n        >\n          <CommandShortcut className=\"text-[.8rem]\" {...badgeProps}>\n            <Badge variant=\"secondary\" size=\"sm\" className=\"p-0 px-2\">\n              {badgeChildren}\n            </Badge>\n          </CommandShortcut>\n          <p className=\"text-sm\">{labelChildren}</p>\n        </TooltipContent>\n      </Tooltip>\n    </div>\n  )\n})\n\nexport interface DuckTableFilterProps<\n  T extends Record<string, any> = Record<string, string>,\n  Y extends keyof Record<string, unknown> = string,\n> extends React.HTMLProps<HTMLDivElement> {\n  filter: ComboboxType<Y, Extract<keyof T, string>>[]\n}\n\nexport const DuckTableFilter = <\n  T extends Record<string, any> = Record<string, string>,\n  Y extends keyof Record<string, unknown> = string,\n>({\n  children,\n  filter,\n  className,\n  ...props\n}: DuckTableFilterProps<T, Y>) => {\n  const { filterBy, setFilterBy } = useDuckTable() ?? {}\n\n  return (\n    <div className={cn('flex items-center gap-2', className)} {...props}>\n      {filter?.map((filter, idx) => {\n        const {\n          className: triggerClassName,\n          children: triggerChildren,\n          ...triggerProps\n        } = filter?.trigger ?? {}\n        return (\n          <Combobox<Y, Extract<keyof T, string>>\n            key={idx}\n            type={'listbox'}\n            title={filter?.title}\n            wrapper={filter?.wrapper}\n            trigger={{\n              icon: { children: CirclePlus },\n              children: (triggerChildren ?? 'not found') as Y,\n              size: 'sm',\n              className: cn('', triggerClassName),\n              ...triggerProps,\n            }}\n            onSelect={\n              filter?.onSelect ?? {\n                value: filterBy as Extract<keyof T, string>[],\n                setValue: setFilterBy as React.Dispatch<\n                  React.SetStateAction<Extract<keyof T, string>[]>\n                >,\n              }\n            }\n            content={{\n              ...filter?.content!,\n            }}\n          />\n        )\n      })}\n    </div>\n  )\n}\n\nexport interface DuckTableBarRightSideProps\n  extends React.HTMLProps<HTMLDivElement> {}\n\nexport const DuckTableBarRightSide = React.forwardRef<\n  HTMLDivElement,\n  DuckTableBarRightSideProps\n>(({ className, children, ...props }, ref) => {\n  return (\n    <div\n      className={cn(\n        'grid lg:flex items-center lg:justify-between gap-2',\n        className,\n      )}\n      ref={ref}\n      {...props}\n    >\n      {children}\n    </div>\n  )\n})\n\nexport interface DuckTableBarLeftSideProps\n  extends React.HTMLProps<HTMLDivElement> {}\n\nexport const DuckTableBarLeftSide = React.forwardRef<\n  HTMLDivElement,\n  DuckTableBarLeftSideProps\n>(({ className, children, ...props }, ref) => {\n  return (\n    <div\n      className={cn(\n        'grid lg:flex items-center lg:justify-between gap-2',\n        className,\n      )}\n      ref={ref}\n      {...props}\n    >\n      {children}\n    </div>\n  )\n})\n\nexport interface DuckTableBarActionsProps<\n  T extends Record<string, unknown>,\n  C extends boolean,\n> {\n  header: TableHeaderType<T, C>[]\n}\n\nexport const TableBarViewButton = <\n  T extends Record<string, any> = Record<string, string>,\n  C extends boolean = false,\n>({\n  header,\n}: DuckTableBarActionsProps<T, C>) => {\n  const { setColumnsViewed, columnsViewed } = useDuckTable<T>() ?? {}\n\n  const option_data = get_options_data<T>({\n    header,\n    columnsViewed,\n    setColumnsViewed,\n  })\n\n  return (\n    <>\n      <DropdownMenuView\n        trigger={{\n          size: 'sm',\n          icon: {\n            children: MixerHorizontalIcon as LucideIcon,\n          },\n          children: 'View',\n          label: {\n            children: 'Toggle columns',\n            showCommand: true,\n            showLabel: true,\n            side: 'top',\n          },\n          command: {\n            key: 'ctrl+shift+v',\n            label: '⌃+⇧+V',\n          },\n        }}\n        content={{\n          label: {\n            children: 'Toggle columns',\n          },\n          options: {\n            itemType: 'checkbox',\n            optionsData: option_data,\n          },\n        }}\n      />\n    </>\n  )\n}\n\nexport type TableBodyRowProps<T extends Record<string, unknown>> = {\n  row?: React.ComponentPropsWithoutRef<typeof TableRow>\n} & Partial<DuckContextMenuProps<T>>\n\nexport const DuckTableBodyRow = <C extends Record<string, unknown>>({\n  wrapper,\n  trigger,\n  content,\n  row,\n}: TableBodyRowProps<C>) => {\n  const { children, ...props } = row ?? {}\n  return (\n    <ContextCustomView\n      trigger={{\n        ...trigger,\n        children: (\n          <TableRow {...props}>{children ?? trigger?.children}</TableRow>\n        ),\n      }}\n      wrapper={wrapper}\n      content={content}\n    />\n  )\n}\n\nexport interface DuckTableFooterProps\n  extends Partial<React.ComponentPropsWithoutRef<typeof TableFooter>> {\n  columns: FooterColumnType[]\n}\nexport type FooterColumnType = Partial<\n  React.ComponentPropsWithoutRef<typeof TableCell>\n>\n\nexport const DuckTableFooter = ({\n  className,\n  columns,\n}: DuckTableFooterProps) => {\n  return (\n    <TableFooter className={cn(className)}>\n      <TableRow>\n        {columns?.map((item, idx) => {\n          const { children, ...props } = item\n          return (\n            <TableCell key={idx} {...props}>\n              {children}\n            </TableCell>\n          )\n        })}\n      </TableRow>\n    </TableFooter>\n  )\n}\n\nexport interface DuckTableDownBarProps\n  extends React.HTMLProps<HTMLDivElement> {}\n\nexport const DuckTableDownBar = ({\n  children,\n  className,\n  ...props\n}: DuckTableDownBarProps) => {\n  return (\n    <>\n      <Separator />\n      <div\n        className={cn(\n          'grid lg:flex items-center lg:justify-between gap-4 lg::gap-0',\n          className,\n        )}\n        {...props}\n      >\n        {children}\n      </div>\n    </>\n  )\n}\nexport type DuckTablePaginationProps = {}\n\nexport const DuckTablePagination = ({}: DuckTablePaginationProps) => {\n  const { pagination, setPagination } = useDuckTable() ?? {}\n  return (\n    /*NOTE: Navigation */\n    <PaginationCustomView\n      right={{\n        onClick: () => {\n          setPagination((old) => ({\n            ...old,\n            pageIndex:\n              old.pageIndex === old.pageSize - 1\n                ? old.pageSize - 1\n                : (old.pageIndex ?? 1) + 1,\n          }))\n        },\n        command: {\n          key: 'ctrl+shift+up',\n          label: '⌃+⇧+↑',\n          // action: () =>\n          //     setPaginationState({\n          //         ...paginationState,\n          //         activePage:\n          //             paginationState.activePage === resultArrays.length - 1\n          //                 ? resultArrays.length - 1\n          //                 : (paginationState.activePage ?? 1) + 1,\n          //     })\n          //     ,\n        },\n        label: {\n          showCommand: true,\n          showLabel: true,\n          side: 'top',\n          children: 'Next page',\n        },\n        // disabled: paginationState.activePage === resultArrays.length - 1,\n      }}\n      maxRight={{\n        // onClick: () => setPaginationState({ ...paginationState, activePage: resultArrays.length - 1 }),\n        // command: {\n        //     key: 'ctrl+shift+right',\n        //     label: '⌃+⇧+→',\n        //     action: () => setPaginationState({ ...paginationState, activePage: resultArrays.length - 1 }),\n        // },\n        label: {\n          showCommand: true,\n          showLabel: true,\n          side: 'top',\n          children: 'Last page',\n        },\n        // disabled: paginationState.activePage === resultArrays.length - 1,\n      }}\n      left={{\n        // onClick: () =>\n        //     setPaginationState({\n        //         ...paginationState,\n        //         activePage: paginationState.activePage === 0 ? 0 : (paginationState.activePage ?? 1) - 1,\n        //     }),\n        // command: {\n        //     key: 'ctrl+shift+down',\n        //     label: '⌃+⇧+↓',\n        //     action: () =>\n        //         setPaginationState({\n        //             ...paginationState,\n        //             activePage: paginationState.activePage === 0 ? 0 : (paginationState.activePage ?? 1) - 1,\n        //         }),\n        // },\n        label: {\n          showCommand: true,\n          showLabel: true,\n          side: 'top',\n          children: 'Previous page',\n        },\n        // disabled: paginationState.activePage === 0,\n      }}\n      maxLeft={{\n        // onClick: () => setPaginationState({ ...paginationState, activePage: 0 }),\n        // command: {\n        //     key: 'ctrl+shift+left',\n        //     label: '⌃+⇧+←',\n        //     action: () => setPaginationState({ ...paginationState, activePage: 0 }),\n        // },\n        label: {\n          showCommand: true,\n          showLabel: true,\n          side: 'top',\n          children: 'First page',\n        },\n        // disabled: paginationState.activePage === 0,\n      }}\n    />\n  )\n}\n\nconst TablePagination = <\n  C extends Record<string, unknown> = Record<string, string>,\n  Y extends keyof Record<string, unknown> = string,\n>({\n  resultArrays,\n  selected,\n  paginationState,\n  paginations,\n  value,\n  tableData,\n  setPaginationState,\n  setValue,\n}: TablePaginationType<C>) => {\n  //NOTE: gen the page length data\n  const pageLengthData = paginations?.groupSize\n    ? Array.from(\n        { length: Math.ceil(tableData.length / paginations.groupSize) },\n        (_, index) => {\n          const start = index * paginations.groupSize + 1\n          const end = Math.min(\n            (index + 1) * paginations.groupSize,\n            tableData.length,\n          )\n          if (start > tableData.length) return null\n          return end.toString()\n        },\n      )\n        .filter(Boolean)\n        .reduce((acc, curr) => {\n          acc.push({ label: curr!, element: { children: curr! } })\n          return acc\n        }, [] as CommandListGroupDataType[])\n    : []\n\n  return (\n    <>\n      <div className=\"grid lg:flex items-center lg:justify-between gap-4 lg::gap-0\">\n        <div className=\"flex items-center justify-between\">\n          {/*NOTE: Select Count */}\n          {paginations?.showSelectCount && (\n            <span className=\"flex items-center justify-center text-sm font-medium text-muted-foreground whitespace-nowrap\">\n              {selected.length} of {tableData.length} row(s) selected.\n            </span>\n          )}\n        </div>\n        <div className=\"flex items-center lg:justify-between lg:gap-4\">\n          {/*NOTE: Group Size */}\n          {paginations?.showGroup && (\n            <div className=\"flex items-center gap-2\">\n              <span className=\"max-2xl:hidden flex items-center justify-center text-sm font-medium text-muted-foreground whitespace-nowrap\">\n                Rows per page\n              </span>\n              <TooltipProvider>\n                <Combobox<Extract<keyof C, string>, Y>\n                  type=\"combobox\"\n                  content={{\n                    data: (pageLengthData ??\n                      []) as CommandListGroupDataType<Y>[],\n                    showSearchInput: false,\n                    className: 'w-[5rem] h-fit',\n                  }}\n                  trigger={{\n                    command: {\n                      key: 'ctrl+shift+c',\n                      label: '⌃+⇧+C',\n                    },\n                    label: {\n                      children: 'Rows per page',\n                      showLabel: true,\n                      side: 'top',\n                      className: 'text-xs',\n                      showCommand: true,\n                    },\n                    className: 'w-[4.5rem] h-[32px] gap-0',\n                  }}\n                  onSelect={{\n                    setValue: setValue as React.Dispatch<\n                      React.SetStateAction<Y[]>\n                    >,\n                    value: value as Y[],\n                  }}\n                />\n              </TooltipProvider>\n            </div>\n          )}\n          {paginations?.showPageCount && (\n            <span className=\"max-lg:hidden flex items-center justify-center text-sm font-medium text-muted-foreground whitespace-nowrap\">\n              Page {paginationState.activePage + 1} of {resultArrays.length}\n            </span>\n          )}\n        </div>\n      </div>\n    </>\n  )\n}\n\nTablePagination.displayName = 'TablePagination'\n\nexport type DuckTableBodyProps<T> = {\n  data: T\n  children: (data: T) => React.ReactNode\n}\n\n//NOTE: Function to split array into chunks\nconst splitIntoChunks = <T,>(array: T[], chunkSize: number) => {\n  const chunks = []\n  for (let i = 0; i < array.length; i += chunkSize) {\n    chunks.push(array.slice(i, i + chunkSize))\n  }\n  return chunks\n}\n\nexport const DuckTableBody = <T,>({\n  data,\n  children,\n}: DuckTableBodyProps<T[]>) => {\n  const { pagination, search, filterBy } = useDuckTable() ?? {}\n  const tableDataGrouped = groupArrays<T>(\n    [pagination?.pageSize ?? PAGE_SIZE],\n    data,\n  )\n  const pageIdx = pagination?.pageIndex ?? PAGE_INDEX\n\n  // NOTE: Filter the items using the search query and filter keys.\n  const filteredData = React.useMemo(() => {\n    if (!tableDataGrouped[pageIdx]?.length) return []\n\n    return tableDataGrouped[pageIdx]?.filter((item) => {\n      const itemValues = Object.values(item as Record<string, unknown>).map(\n        (value) => JSON.stringify(value).toLowerCase(),\n      )\n\n      const matchesSearch = search?.query\n        ? itemValues.some((value) => value.includes(search.query.toLowerCase()))\n        : false\n\n      const matchesFilterBy = filterBy?.length\n        ? itemValues.some((value) =>\n            filterBy.some((q) => value.includes(q.toLowerCase())),\n          )\n        : false\n\n      return (\n        (!search?.query && !filterBy?.length) ||\n        matchesSearch ||\n        matchesFilterBy\n      )\n    })\n  }, [search, filterBy, tableDataGrouped, pageIdx])\n\n  // NOTE: Split the data into chunks based on the group size.\n  const resultArrays = React.useMemo(\n    () => splitIntoChunks(filteredData, pagination?.pageSize ?? PAGE_SIZE),\n    [filteredData, pagination?.pageSize],\n  )\n\n  console.log(filteredData)\n\n  return (\n    (resultArrays[pageIdx]?.length ?? 0 > 0) && (\n      <TableBody>{children(resultArrays[pageIdx] as T[])}</TableBody>\n    )\n  )\n}\n\nexport const EmptyTable = () => {\n  return (\n    <div className=\"w-full h-full flex items-center justify-center absolute top-1/2 left-1/2\">\n      <h6 className=\"text-muted-foreground text-center\"> No data </h6>\n    </div>\n  )\n}\n\nexport interface DuckTableProps\n  extends React.ComponentPropsWithoutRef<typeof Table> {\n  wrapper?: React.ComponentPropsWithoutRef<typeof ScrollArea>\n}\n\n// const {children: captionChildren, className: captionClassName, ...captionProps } = caption! ?? []\n// const [selected, setSelected] = React.useState<TableContentDataType<C>[]>([])\n// const [tableData, setTableData] = React.useState<TableContentDataType<C>[]>(tableContentData)\n// const [paginationState, setPaginationState] = React.useState({\n//     activePage: pagination?.activePage ?? 0,\n//     groupSize: pagination?.groupSize ?? tableData.length,\n// })\n// const [headers, setHeaders] = React.useState<TableHeaderType<T, C>[]>(header ?? [])\n// const [search, setSearch] = React.useState<{ q: string; qBy: string[] }>({q: '', qBy: [] })\n// const [value, setValue] = React.useState<string[]>([paginationState.groupSize.toString()])\n//\n// const [filterLabels, setFilterLabels] = React.useState<{ [key: string]: number }>({})\n//\n// //NOTE: Function to split array into chunks\n// const splitIntoChunks = (array: typeof tableData, chunkSize: number) => {\n//     const chunks = []\n//     for (let i = 0; i < array.length; i += chunkSize) {\n//         chunks.push(array.slice(i, i + chunkSize))\n//     }\n//     return chunks\n// }\n//\n// const filteredData = React.useMemo(() => {\n//     //NOTE: Step 1: Filter the data based on search.q and search.qBy\n//     const data = tableData.filter(item => {\n//         return !search.qBy.length\n//             ? Object.values(item).some(value => JSON.stringify(value).toLowerCase().includes(search.q.toLowerCase()))\n//             : Object.values(item).some(value =>\n//                 search.qBy.some(q => JSON.stringify(value).toLowerCase().includes(q.toLowerCase()))\n//             )\n//     })\n//\n//     //NOTE: Step 2: Calculate label counts based on the filtered data\n//     const labelCounts: {[key: string]: number } = {}\n//     data.forEach(item => {\n//         Object.values(item).forEach(value => {\n//             filters?.forEach(filter => {\n//                 filter?.content?.data.forEach(option => {\n//                     const label = option?.label?.toString().toLowerCase()\n//                     if (\n//                         JSON.stringify(value)\n//                             .toLowerCase()\n//                             .includes(label ?? '')\n//                     ) {\n//                         labelCounts[label ?? ''] = (labelCounts[label ?? ''] || 0) + 1\n//                     }\n//                 })\n//             })\n//         })\n//     })\n//\n//     setFilterLabels(labelCounts)\n//\n//     return data\n// }, [tableData, filters, search])\n//\n// //NOTE: Step 3: Update the filters to display the count based on the filtered data\n// const updatedFilters = React.useMemo(() => {\n//     return filters?.map(filter => {\n//         return {\n//             ...filter,\n//             content: {\n//                 ...filter.content,\n//                 data: filter?.content?.data.map(option => {\n//                     const label = option?.label?.toString().toLowerCase()\n//                     return {\n//                         ...option,\n//                         element: {\n//                             ...option.element,\n//                             label: {\n//                                 ...option?.element?.label,\n//                                 children: filterLabels[label ?? ''] || 0,\n//                             },\n//                         },\n//                     }\n//                 }),\n//             },\n//         }\n//     })\n// }, [filters, filterLabels])\n//\n// //NOTE: Step 4: Split the data into chunks based on the groupSize\n// const resultArrays = splitIntoChunks(filteredData, +value)\n\n// {tableData && !!resultArrays.length && (\n//     <TableCustomBody<T, C, Y>\n//         headers={headers}\n//         resultArrays={resultArrays}\n//         paginationState={paginationState}\n//         selection={selection ?? false}\n//         selected={selected}\n//         filtersData={filters}\n//         setSelected={setSelected}\n//         dropdownMenu={dropdownMenu ?? {}}\n//         contextMenu={contextMenu ?? {}}\n//     />\n// )}\n// {footer?.columns && <TableCustomFooter {...footer} />}\n// {caption && (\n//     <div\n//         className={cn('mb-4 text-sm text-muted-foreground text-center', captionClassName)}\n//         {...captionProps}\n//     >\n//             {caption?.children}\n//         </div>\n// )}\n// {pagination && (\n//     <TablePagination<C>\n//         selected={selected}\n//         value={value}\n//         tableData={tableData}\n//         resultArrays={resultArrays}\n//         paginationState={paginationState}\n//         paginations={pagination}\n//         setValue={setValue}\n//         setPaginationState={setPaginationState}\n//     />\n// )}\n\nexport {\n  Table,\n  TableHeader,\n  TableBody,\n  TableFooter,\n  TableHead,\n  TableRow,\n  TableCell,\n  TableCaption,\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry-ui-components/table/table.types.ts",
      "content": "import { ScrollArea } from '@/registry/default/ui/scroll-area'\nimport { sortArray } from './table.lib'\nimport { TableCell, TableFooter, TablePaginationStateType } from './table'\nimport { ComboboxType } from '@/registry/default/ui/combobox'\nimport { ContextMenuOptionsType } from '@/registry/default/ui/context-menu'\nimport {\n  DropdownMenuOptionsDataType,\n  DropdownMenuOptionsType,\n} from '@/registry/default/ui/dropdown-menu'\nimport { IconType, LabelType } from '../button'\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nexport type Order = 'asc' | 'desc' | 'not sorted'\n\nexport interface TableDropdownMenuOptionsType<\n  T extends Record<string, any>,\n  C extends boolean,\n> {\n  sortArray: typeof sortArray\n  setHeaders: React.Dispatch<React.SetStateAction<TableHeaderType<T, C>[]>>\n  headers: TableHeaderType<T, C>[]\n  tableData: TableContentDataType<T>[]\n  setTableData: React.Dispatch<React.SetStateAction<TableContentDataType<T>[]>>\n  data: TableContentDataType<T>[]\n  idx: number\n  column: TableHeaderType<T, C>\n}\n\nexport interface TableHeaderType<C extends boolean = true>\n  extends Partial<React.HTMLProps<HTMLTableCellElement>> {\n  label: string\n  sortable?: boolean\n  showLabel?: boolean\n  currentSort?: C extends true ? 'asc' | 'desc' | 'not sorted' : never\n  // dropdownMenuOptions?: C extends true\n  //   ? DropdownMenuOptionsDataType<TableDropdownMenuOptionsType<T, C>>[]\n  //   : never\n}\n\nexport interface TableHeaderActionsProps<\n  T extends Record<string, unknown>,\n  K extends boolean,\n> {\n  header: TableHeaderType<T, K>[]\n  headers: TableHeaderType<T, K>[]\n  setHeaders: React.Dispatch<React.SetStateAction<TableHeaderType<T, K>[]>>\n}\n\n// TableHeaderOptions\nexport interface TableHeaderOptionsType<\n  T extends Record<string, any>,\n  C extends boolean,\n> {\n  sortArray: typeof sortArray\n  setHeaders: React.Dispatch<React.SetStateAction<TableHeaderType<T, C>[]>>\n  headers: TableHeaderType<T, C>[]\n  tableData: TableContentDataType<T>[]\n  setTableData: React.Dispatch<React.SetStateAction<TableContentDataType<T>[]>>\n  data: TableContentDataType<T>[]\n  idx: number\n  column: TableHeaderType<T, C>\n}\n\n// TableCustomBody\nexport interface TableCustomBodyProps<\n  T extends Record<string, unknown>,\n  Y extends keyof Record<string, unknown>,\n  C extends boolean,\n> {\n  headers: TableHeaderType<T, C>[]\n  resultArrays: TableContentDataType<T>[][]\n  paginationState: PaginationState\n  selection: boolean\n  selected: TableContentDataType<T>[]\n  setSelected: React.Dispatch<React.SetStateAction<TableContentDataType<T>[]>>\n  dropdownMenu: DropdownMenuOptionsType<TableHeaderOptionsType<T, C>>\n  contextMenu: ContextMenuOptionsType<TableHeaderOptionsType<T, C>>\n  filtersData: ComboboxType<Extract<keyof C, string>, Y>[] | undefined\n}\n\n// TableCustomFooter\n\n// TablePagination\n\nexport interface TableDataKey extends React.HTMLProps<HTMLTableCellElement> {\n  withLabel?: Omit<LabelType, 'showCommand' | 'showLabel'>\n  withIcon?: React.ReactNode\n}\nexport interface TableCaptionType\n  extends React.HTMLProps<HTMLTableCaptionElement> {}\nexport interface TablePaginationsType extends React.HTMLProps<HTMLDivElement> {\n  groupSize: number\n  activePage?: number\n  showPageCount?: boolean\n  showSelectCount?: boolean\n  showNavigation?: boolean\n  showGroup?: boolean\n}\n\nexport interface PaginationState {\n  activePage: number\n  groupSize: number\n}\n\nexport interface TablePaginationType<\n  C extends Record<string, any> = Record<string, string>,\n> {\n  selected: TableContentDataType<C>[]\n  setValue: React.Dispatch<React.SetStateAction<string[]>>\n  value: string[]\n  tableData: TableContentDataType<C>[]\n  paginations?: TablePaginationsType\n  resultArrays: TableContentDataType<C>[][]\n  paginationState: PaginationState\n  setPaginationState: React.Dispatch<React.SetStateAction<PaginationState>>\n}\n\n// TableCustomView\n",
      "type": "registry:ui"
    }
  ]
}